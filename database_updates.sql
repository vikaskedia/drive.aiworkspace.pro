-- Database Updates for Folder Sharing Feature
-- Run these queries manually in Supabase SQL Editor

-- 1. Create the folder_shares table
CREATE TABLE IF NOT EXISTS folder_shares (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    workspace_id bigint REFERENCES workspaces(id) NOT NULL,
    folder_path text NOT NULL,
    share_token character varying(64) UNIQUE NOT NULL,
    shared_by uuid REFERENCES auth.users(id) NOT NULL,
    shared_with_description text,
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    access_count integer DEFAULT 0 NOT NULL,
    last_accessed_at timestamp with time zone
);

-- 2. Add table comment
COMMENT ON TABLE folder_shares IS 'Manages temporary folder sharing with expiry dates. 
Each share provides view-only access to a specific folder within a workspace.
- share_token: Unique token used in the shareable URL
- shared_with_description: Optional description of who the link is being shared with
- expires_at: When the share expires (NULL means no expiry)
- is_active: Can be deactivated before expiry
- access_count: Tracks how many times the share has been accessed
- last_accessed_at: When the share was last accessed';

-- 3. Create indexes
CREATE INDEX IF NOT EXISTS folder_shares_workspace_id_idx ON folder_shares USING btree (workspace_id);
CREATE INDEX IF NOT EXISTS folder_shares_share_token_idx ON folder_shares USING btree (share_token);
CREATE INDEX IF NOT EXISTS folder_shares_shared_by_idx ON folder_shares USING btree (shared_by);
CREATE INDEX IF NOT EXISTS folder_shares_expires_at_idx ON folder_shares USING btree (expires_at);
CREATE INDEX IF NOT EXISTS folder_shares_is_active_idx ON folder_shares USING btree (is_active);

-- 4. Enable Row Level Security
ALTER TABLE folder_shares ENABLE ROW LEVEL SECURITY;

-- 5. Drop existing policies if they exist (to avoid conflicts)
DROP POLICY IF EXISTS "Users can view folder shares" ON folder_shares;
DROP POLICY IF EXISTS "Allow anonymous access to valid shares" ON folder_shares;
DROP POLICY IF EXISTS "Users can view their own shares" ON folder_shares;
DROP POLICY IF EXISTS "Users with edit access can create folder shares" ON folder_shares;
DROP POLICY IF EXISTS "Users can update their folder shares" ON folder_shares;
DROP POLICY IF EXISTS "Users can delete their folder shares" ON folder_shares;

-- 6. Create new RLS policies
-- Policy for anonymous access to valid shares
CREATE POLICY "Allow anonymous access to valid shares" ON folder_shares
AS PERMISSIVE
FOR SELECT 
TO anon, authenticated 
USING (
    is_active = true 
    AND (expires_at IS NULL OR expires_at > now())
);

-- Policy for authenticated users to view their own shares
CREATE POLICY "Users can view their own shares" ON folder_shares
AS PERMISSIVE
FOR SELECT 
TO authenticated 
USING (shared_by = auth.uid());

-- Policy for inserting data - users with edit access can create shares
CREATE POLICY "Users with edit access can create folder shares" ON folder_shares
AS PERMISSIVE
FOR INSERT 
TO authenticated 
WITH CHECK (
    shared_by = auth.uid()
    AND workspace_id IN (
        SELECT workspace_id 
        FROM workspace_access 
        WHERE shared_with_user_id = auth.uid() 
        AND access_type = 'edit'
    )
);

-- Policy for updating data - users can update their own shares
CREATE POLICY "Users can update their folder shares" ON folder_shares
AS PERMISSIVE
FOR UPDATE 
TO authenticated 
USING (shared_by = auth.uid())
WITH CHECK (shared_by = auth.uid());

-- Policy for deleting data - users can delete their own shares
CREATE POLICY "Users can delete their folder shares" ON folder_shares
AS PERMISSIVE
FOR DELETE 
TO authenticated 
USING (shared_by = auth.uid());

-- 7. Create function to generate unique share token
CREATE OR REPLACE FUNCTION generate_share_token()
RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
    token text;
    exists boolean;
BEGIN
    LOOP
        -- Generate a random 32-character token
        token := encode(gen_random_bytes(16), 'hex');
        
        -- Check if token already exists
        SELECT EXISTS(SELECT 1 FROM folder_shares WHERE share_token = token) INTO exists;
        
        -- If token doesn't exist, return it
        IF NOT exists THEN
            RETURN token;
        END IF;
    END LOOP;
END;
$$;

-- 8. Create function to increment access count
CREATE OR REPLACE FUNCTION increment_share_access(share_token_param text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    share_exists boolean;
BEGIN
    -- Check if share exists and is active
    SELECT EXISTS(
        SELECT 1 FROM folder_shares 
        WHERE share_token = share_token_param 
        AND is_active = true 
        AND (expires_at IS NULL OR expires_at > now())
    ) INTO share_exists;
    
    IF share_exists THEN
        -- Increment access count and update last accessed time
        UPDATE folder_shares 
        SET access_count = access_count + 1,
            last_accessed_at = now()
        WHERE share_token = share_token_param;
        
        RETURN true;
    ELSE
        RETURN false;
    END IF;
END;
$$;

-- 9. Grant execute permission to anonymous users
GRANT EXECUTE ON FUNCTION increment_share_access(text) TO anon;

-- 10. Verify the setup
SELECT 'Folder sharing setup completed successfully!' as status;

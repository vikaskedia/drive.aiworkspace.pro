-- Database Updates for Folder Sharing Feature
-- Run these queries manually in Supabase SQL Editor

-- 1. Create the folder_shares table
CREATE TABLE IF NOT EXISTS folder_shares (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    workspace_id bigint REFERENCES workspaces(id) NOT NULL,
    folder_path text NOT NULL,
    share_token character varying(64) UNIQUE NOT NULL,
    shared_by uuid REFERENCES auth.users(id) NOT NULL,
    shared_with_description text,
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    access_count integer DEFAULT 0 NOT NULL,
    last_accessed_at timestamp with time zone
);

-- 2. Add table comment
COMMENT ON TABLE folder_shares IS 'Manages temporary folder sharing with expiry dates. 
Each share provides view-only access to a specific folder within a workspace.
- share_token: Unique token used in the shareable URL
- shared_with_description: Optional description of who the link is being shared with
- expires_at: When the share expires (NULL means no expiry)
- is_active: Can be deactivated before expiry
- access_count: Tracks how many times the share has been accessed
- last_accessed_at: When the share was last accessed';

-- 3. Create indexes
CREATE INDEX IF NOT EXISTS folder_shares_workspace_id_idx ON folder_shares USING btree (workspace_id);
CREATE INDEX IF NOT EXISTS folder_shares_share_token_idx ON folder_shares USING btree (share_token);
CREATE INDEX IF NOT EXISTS folder_shares_shared_by_idx ON folder_shares USING btree (shared_by);
CREATE INDEX IF NOT EXISTS folder_shares_expires_at_idx ON folder_shares USING btree (expires_at);
CREATE INDEX IF NOT EXISTS folder_shares_is_active_idx ON folder_shares USING btree (is_active);

-- 4. Enable Row Level Security
ALTER TABLE folder_shares ENABLE ROW LEVEL SECURITY;

-- 5. Drop existing policies if they exist (to avoid conflicts)
DROP POLICY IF EXISTS "Users can view folder shares" ON folder_shares;
DROP POLICY IF EXISTS "Allow anonymous access to valid shares" ON folder_shares;
DROP POLICY IF EXISTS "Users can view their own shares" ON folder_shares;
DROP POLICY IF EXISTS "Users with edit access can create folder shares" ON folder_shares;
DROP POLICY IF EXISTS "Users can update their folder shares" ON folder_shares;
DROP POLICY IF EXISTS "Users can delete their folder shares" ON folder_shares;

-- 6. Create new RLS policies
-- Policy for anonymous access to valid shares
CREATE POLICY "Allow anonymous access to valid shares" ON folder_shares
AS PERMISSIVE
FOR SELECT 
TO anon, authenticated 
USING (
    is_active = true 
    AND (expires_at IS NULL OR expires_at > now())
);

-- Policy for authenticated users to view their own shares
CREATE POLICY "Users can view their own shares" ON folder_shares
AS PERMISSIVE
FOR SELECT 
TO authenticated 
USING (shared_by = auth.uid());

-- Policy for inserting data - users with edit access can create shares
CREATE POLICY "Users with edit access can create folder shares" ON folder_shares
AS PERMISSIVE
FOR INSERT 
TO authenticated 
WITH CHECK (
    shared_by = auth.uid()
    AND workspace_id IN (
        SELECT workspace_id 
        FROM workspace_access 
        WHERE shared_with_user_id = auth.uid() 
        AND access_type = 'edit'
    )
);

-- Policy for updating data - users can update their own shares
CREATE POLICY "Users can update their folder shares" ON folder_shares
AS PERMISSIVE
FOR UPDATE 
TO authenticated 
USING (shared_by = auth.uid())
WITH CHECK (shared_by = auth.uid());

-- Policy for deleting data - users can delete their own shares
CREATE POLICY "Users can delete their folder shares" ON folder_shares
AS PERMISSIVE
FOR DELETE 
TO authenticated 
USING (shared_by = auth.uid());

-- 7. Create function to generate unique share token
CREATE OR REPLACE FUNCTION generate_share_token()
RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
    token text;
    exists boolean;
BEGIN
    LOOP
        -- Generate a random 32-character token
        token := encode(gen_random_bytes(16), 'hex');
        
        -- Check if token already exists
        SELECT EXISTS(SELECT 1 FROM folder_shares WHERE share_token = token) INTO exists;
        
        -- If token doesn't exist, return it
        IF NOT exists THEN
            RETURN token;
        END IF;
    END LOOP;
END;
$$;

-- 8. Create function to increment access count
CREATE OR REPLACE FUNCTION increment_share_access(share_token_param text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    share_exists boolean;
BEGIN
    -- Check if share exists and is active
    SELECT EXISTS(
        SELECT 1 FROM folder_shares 
        WHERE share_token = share_token_param 
        AND is_active = true 
        AND (expires_at IS NULL OR expires_at > now())
    ) INTO share_exists;
    
    IF share_exists THEN
        -- Increment access count and update last accessed time
        UPDATE folder_shares 
        SET access_count = access_count + 1,
            last_accessed_at = now()
        WHERE share_token = share_token_param;
        
        RETURN true;
    ELSE
        RETURN false;
    END IF;
END;
$$;

-- 9. Grant execute permission to anonymous users
GRANT EXECUTE ON FUNCTION increment_share_access(text) TO anon;

-- 10. Create folder_share_access_logs table for detailed IP tracking
CREATE TABLE IF NOT EXISTS folder_share_access_logs (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    share_id bigint REFERENCES folder_shares(id) ON DELETE CASCADE NOT NULL,
    ip_address inet NOT NULL,
    user_agent text,
    accessed_at timestamp with time zone DEFAULT now() NOT NULL,
    session_duration_seconds integer,
    files_viewed integer DEFAULT 0,
    folders_navigated integer DEFAULT 0
);

-- 11. Add comment for access logs table
COMMENT ON TABLE folder_share_access_logs IS 'Tracks detailed access logs for shared folders including IP addresses, user agents, and usage statistics.
- share_id: References the folder share that was accessed
- ip_address: IP address of the user who accessed the share
- user_agent: Browser/client information
- accessed_at: When the access occurred
- session_duration_seconds: How long the user stayed (calculated when they leave)
- files_viewed: Number of files the user viewed/downloaded
- folders_navigated: Number of folder navigations the user made';

-- 12. Create indexes for access logs
CREATE INDEX IF NOT EXISTS folder_share_access_logs_share_id_idx ON folder_share_access_logs USING btree (share_id);
CREATE INDEX IF NOT EXISTS folder_share_access_logs_ip_address_idx ON folder_share_access_logs USING btree (ip_address);
CREATE INDEX IF NOT EXISTS folder_share_access_logs_accessed_at_idx ON folder_share_access_logs USING btree (accessed_at);

-- 13. Enable RLS for access logs
ALTER TABLE folder_share_access_logs ENABLE ROW LEVEL SECURITY;

-- 14. Create RLS policies for access logs
-- Policy for selecting data - allow authenticated users to view logs for their own shares
CREATE POLICY "Users can view access logs for their own shares" ON folder_share_access_logs
AS PERMISSIVE
FOR SELECT 
TO authenticated 
USING (
    share_id IN (
        SELECT id FROM folder_shares WHERE shared_by = auth.uid()
    )
);

-- Policy for inserting data - allow anonymous access for logging
CREATE POLICY "Allow anonymous access logging" ON folder_share_access_logs
AS PERMISSIVE
FOR INSERT 
TO anon, authenticated 
WITH CHECK (true);

-- Policy for updating data - allow anonymous users to update their session data
CREATE POLICY "Allow anonymous session updates" ON folder_share_access_logs
AS PERMISSIVE
FOR UPDATE 
TO anon, authenticated 
USING (true)
WITH CHECK (true);

-- 15. Create function to log share access with IP address
CREATE OR REPLACE FUNCTION log_share_access(
    share_token_param text,
    ip_address_param inet,
    user_agent_param text DEFAULT NULL
)
RETURNS bigint
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    share_id bigint;
    access_log_id bigint;
BEGIN
    -- Get the share ID from the token
    SELECT id INTO share_id
    FROM folder_shares 
    WHERE share_token = share_token_param 
    AND is_active = true 
    AND (expires_at IS NULL OR expires_at > now());
    
    IF share_id IS NULL THEN
        RETURN NULL;
    END IF;
    
    -- Insert access log
    INSERT INTO folder_share_access_logs (
        share_id,
        ip_address,
        user_agent,
        accessed_at
    ) VALUES (
        share_id,
        ip_address_param,
        user_agent_param,
        now()
    ) RETURNING id INTO access_log_id;
    
    -- Update the main share access count and last accessed time
    UPDATE folder_shares 
    SET access_count = access_count + 1,
        last_accessed_at = now()
    WHERE id = share_id;
    
    RETURN access_log_id;
END;
$$;

-- 16. Create function to update session duration when user leaves
CREATE OR REPLACE FUNCTION update_session_duration(
    access_log_id_param bigint,
    session_duration_seconds_param integer,
    files_viewed_param integer DEFAULT 0,
    folders_navigated_param integer DEFAULT 0
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    UPDATE folder_share_access_logs 
    SET session_duration_seconds = session_duration_seconds_param,
        files_viewed = files_viewed_param,
        folders_navigated = folders_navigated_param
    WHERE id = access_log_id_param;
    
    RETURN FOUND;
END;
$$;

-- 17. Grant execute permissions for new functions
GRANT EXECUTE ON FUNCTION log_share_access(text, inet, text) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION update_session_duration(bigint, integer, integer, integer) TO anon, authenticated;

-- 18. Verify the setup
SELECT 'Folder sharing with IP tracking setup completed successfully!' as status;
